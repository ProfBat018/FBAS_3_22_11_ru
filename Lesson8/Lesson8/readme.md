# Темы урока: 
* Generics
* Delegates

## Generics
`Generics` - это обобщения. 
По сути это тоже самое, что и шаблоны в C++.
Правда есть отличия и немного другие мотивы использования.


Все мы знаем что в C# есть два типа данных: `значимые` и `ссылочные`.
Если у нас есть класс, который принимает в себя object, то мы можем передать в него любой тип данных.

Что если, нам нужно принимать все типы данных, которые являются ссылочными ?
или тоже самое, но для значимых типов данных ?
или все типы  данных, с конструктором по умолчанию ?
или все типы данных, которые реализуют определенный интерфейс ?

По факту как я уже сказал выше, все тоже самое что и в C++, но у нас другие цели. 
Мы и так и так можем приниаать любой тип, как например с `ArrayList`

```csharp

using System;
using System.Collections;

ArrayList list = new() {1, "2", true, 4.4m, 5};
```

Но вот проблема, что мы не можем получить доступ к элементам, так как они все object.
И нам нужно приводить их к нужному типу.

```csharp
using System;
using System.Collections.Generic;

List<int> list = new() {1, 2, 3, 4, 5};
```

Вот тут мы можем получить доступ к элементам, так как мы знаем что это int.

Следующие примеры в `Program.cs`


## Delegates.

Сегодня мы поговорим про первую часть делегатов. 
Собственно мы сделаем небольшое введение в делегаты и проведем параллели с обобщениями.

Делегаты - это указатели на функции из С++. 

Есть три типа встроенных делегатов:
* Action. Void делегаты.
* Func. Принимает до 16 параметров и возвращает значение.
* Predicate. Принимает один параметр и возвращает bool.

Все они находятся в пространстве имен `System`

Пример использования делегатов в `Program.cs`


```csharp

// Возвращает void. Не принимает параметров
Action a = () => Console.WriteLine("Hello");

// Возвращает void. Принимает один параметр типа int
Action<int> b = (int x) => Console.WriteLine(x);

// Прием двух параметров типа int и возвращает bool
Func<int, int, bool> c = (int x, int y) => ((x + y) % 2 == 0);

// Возвращает bool. Принимает один параметр типа int
Predicate<int> d = (int x) => (x % 2 == 0);

```

Если Func может возвращать bool, то зачем нужен Predicate ?

Все дело в семантике и в принимаемых значениях. Смотрите => 

При всем условии, что Func может полностью заменить Predicate, но семантика у них разная.

```csharp
Func<int, bool> func = (int x) => (x % 2 == 0);

Predicate<int> predicate = (int x) => (x % 2 == 0);
```

тут стоит отметить что их создали в разное время.

Вот так выглядит сигнатура Predicate

```csharp
public delegate bool Predicate<in T>(T obj);
```
А вот так Func
```csharp
public delegate TResult Func<in T, out TResult>(T arg);
```

Плюс есть еще одно отличие, которое касается принимаемых значений.

Некоторые библиотеки и фреймворки используют Predicate, а некоторые Func.
Из-за этого пришлось отсавить Predicate.

